---
layout: article
title: 我重写了五次队列之后
subtitle: 一次基于 TDD 与重构的代码演进实验
description: 在重写五次队列的过程中，我并非在修复 bug，而是在校准思维。本文记录了一次基于 TDD 与重构的代码演进实验，探讨如何通过抽象与组合，让代码在面对多种实现变体时依然保持清晰。
tags: [tdd, refactor, data-structure, design-pattern, explanation]
lang: zh
---

> “我最初只想要一个能 `push` 和 `pop` 的东西。”  
> —— 某个平静的夜晚，键盘轻响

最近，我重新翻开《数据结构与算法》的课本，像一个刚入学的学生一样，从头实现每一个基础结构。

不是为了解决实际问题，也不是为了刷题。而是我发现，随着工作经验的增长，我对“什么是好代码”的理解，早已不同于学生时代。

学生时期的我，只关心“能不能跑”；现在的我，更在意“能不能演进”。

于是，我决定用 TDD 的方式，从零实现一个队列。  
不是写一次，而是**写五次**。

每一次重写，都不是为了修复 bug，而是为了回答一个问题：  
> **当实现方式、数据结构、边界条件自由组合时，代码该如何保持清晰？**

---

### 第一次：最简单的队列，用列表实现

我从最基础的 FIFO 行为开始。

先写测试：

```python
def test_queue_push_pop():
    q = Queue()
    q.push(1)
    q.push(2)
    assert q.pop() == 1
    assert q.pop() == 2
```

然后实现：

```python
class Queue:
    def __init__(self):
        self._items = []
    
    def push(self, item):
        self._items.append(item)
    
    def pop(self):
        return self._items.pop(0)
```

这是最纯粹的队列：无界、顺序存储、单向操作。  
它像一张白纸，尚未被任何选择污染。

测试通过，我提交了第一个版本：
`feat: implement basic queue with list`

那一刻，世界安静。

---

### 第二次：我想看看所有可能的变体

我不满足于只实现一种队列。 

我想探索它的**实现空间**：  
- 底层结构：列表、链表、Python 内置 deque
- 边界：有界、无界
- 形式：普通队列、循环队列、双端队列

尽管不是每一种组合都有实际意义，但是确实都可以成为不同的实现队列的方式。

于是我为每一种组合编写测试：
`test_circular_queue_by_linked_list`、`test_unbounded_deque`、`test_bounded_queue`……

我一口气实现了多个类：`CircularQueue`、`BoundedQueue`、`Deque`……  
每个都有独立的测试，每个都能通过。

但很快，我发现了问题。

---

### 第三次：代码开始重复，我意识到“霰弹式修改”

当我修改 `is_empty` 的判断逻辑时，我不得不去改五个类。
当我修复 `pop` 的边界检查时，我又得重复同样的逻辑。

更糟的是，`CircularQueue` 和 `BoundedQueue` 都有 `max_size`，但一个用指针，一个用列表，行为相似，实现却完全不同。

我陷入了**霰弹式修改**：一个概念的变化，需要在多个地方同步。

而且明明只是一个数据结构，却要维护多个类，就好像它们之间没有关系一样，这种情况很让人觉得别扭。

这时我才明白：  
> **我不是在写多个队列，我是在复制粘贴中制造认知碎片。**

每一个类都像是孤岛，彼此之间没有对话。  
我本以为我在“覆盖所有情况”，实际上我在**制造混乱**。

---

### 第四次：我尝试用继承统一它们

既然有共性，为什么不继承？

我创建了一个基类，试图统一 `max_size`、`is_empty` 等共性逻辑。

但问题来了：  
- `CircularQueue` 需要 `head`、`tail` 指针，`ListQueue` 不需要；
- `Deque` 支持双向操作，其他不支持；
- 有些用 `list`，有些用 `array`，初始化方式不同。

我不得不在基类里加 `if-else`，或者让子类重写大量方法。  
继承树变得僵硬，**一个子类的改动，开始影响其他无关类**。

我意识到：  
> **继承不是在复用代码，而是在强制共享状态。**

而队列的不同变体，本质上是**策略不同**，不是“类型谱系”。  
用继承去统一它们，就像试图用一把钥匙打开所有锁——有些能转，但都不顺。

我删掉了基类。  
这一次尝试，让我更清楚地看到了问题的本质：  
我们真正需要解耦的，不是“队列的类型”，而是“**数据的组织方式**”。

---

### 第五次：我引入了 `Container`，让存储与行为分离

我没有继续扩展类 hierarchy，而是回到测试，重新思考接口的职责。

在一次提交中，我定义了 `Container` 抽象：

```python
class Container(ABC):
    @abstractmethod
    def insert(self, item, position): ...
    
    @abstractmethod
    def pop(self): ...
    
    @property
    @abstractmethod
    def is_empty(self): ...
```

这个抽象的出现，标志着一次思维跃迁：  
我不再关心“队列是什么”，而是问“它用什么来存”。也不再关心队列的操作怎么实现，而是把实现下放到 Container 中。

随后，我为不同实现编写了具体容器：

- `DynamicArray`
- `CircularBuffer`
- `BoundedDeque`
- ...

而 `Queue` 本身变得极其轻量，站在它的视角，它只需要调用 Containers 的功能，实现队列的基本操作。

```python
class Queue:
    def __init__(self, container: Container):
        self._container = container
    
    def push(self, item):
        if self._container.is_full():
            raise QueueFullError()
        self._container.insert(item, -1)
    
    def pop(self):
        if self._container.is_empty():
            raise QueueEmptyError()
        return self._container.pop()
```


对于具体的插入、删除、查询数据的行为，则由每一个 Container 自己负责，不用队列类来干预。这是因为不同的 Container 有不同的实现方式，这是天然的差异，为每种 Container 编写实现代码是很自然的；而队列作为一个概念，只有一套行为，因为也就只有一套定义，这样逻辑上也很统一。

而且注意队列的操作是 `push`，但 Container 的操作是 `insert`，这是因为它们所处的抽象层次不同，队列的入队操作只是 container 的插入操作的一个特例。在这里根据抽象层次（或者说领域）来定义操作，会让结构变得更加清晰。

这一次，我没有再为“有界”“环形”“双端”去创建新队列类，而是通过**组合不同的 `Container` 实现**来达成目标。代码的结构，已经从“树状继承”变成了“星型组合”。

---

## 五次重写，五次觉醒

回看这五次重写：

- 第一次，我写的是**功能**；
- 第二次，我写的是**变体**；
- 第三次，我发现了**重复**；
- 第四次，我误入了**继承的窄门**；
- 第五次，我才真正开始**设计**。

我意识到，真正的基本功，不是会写 `push` 和 `pop`，而是**在应对实现方式的各种组合时，如何不让代码的复杂度，超过问题本身的复杂度。**

学生时代的我们，总以为“掌握数据结构”就是闭着眼睛也能把书上的代码快速还原到编辑器里。
工作多年后才明白，**真正的掌握，是在你面对复杂情况时，依然可以让代码保持整洁**。

这，或许就是 TDD 与重构教会我的最重要一课：  
**代码不是写出来的，是演进出来的。而每一次重写，都是对思维的一次校准。**

---

## 后记

这篇文章写完后，我忍不住又重新运行了早就通过的所有测试，反复翻看源码。这是一个没有临时方案，没有“勿动”注释，没有胶带缠绕的代码。只有清晰的边界，和可以自由替换的实现。

看着这样的代码，世界又重新安静了下来。