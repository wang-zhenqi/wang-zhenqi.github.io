---
layout: post
title: "Python 代码中应避免将函数参数的默认值定义为可变对象"
description: "本文主要分析了 Python 的可变对象与不可变对象的区别，赋值操作与对象的引用，以及为什么不建议将函数参数的默认值设定为可变对象"
tags: [programming, python, explanation]
---

## 可变对象与不可变对象

Python 中的可变对象指的是列表（list）、集合（set）和字典（dict）。对应的，不可变对象指的是基本类型（int, float, long, str）以及元组（tuple）。

可变与否主要指的是该对象的值是否能够被更改。例如，对于一个整型数据 `88`，它的值在定义之后就固定了；而对于一个列表 `[1, 2, 3]`，它的元素是可以被修改的。代码如下：

```python
a = 1
print(id(a))
a = 2
print(id(a))
# 可以看到以上两个地址是不同的，这说明对于不可变对象，只能生成新的对象，而不能修改

l = [1, 2, 3]
print(id(l))
l[0] = 4
print(id(l))
# 可以看到以上两个地址是相同的，更改可变对象的值，并不会生成新对象。
```

## 赋值还是引用？

在 Python 中，赋值操作 `=`本质上是将对象的地址赋给一个标识符，可以理解为给一段内存地址打了个标签，标签名为该标识符。例如 `a = 3`这条语句，编译器先分配了一段内存，用数值“3“初始化了一个整型对象，再将这个对象的地址标记为“a”。这个行为其实更像是 C/C++ 语言中的指针操作。

对于不可变对象来说，`l = [1, 2, 3]` 也是先用数值1,2,3 在内存中生成了一个列表对象，再将其标记为`l`。那么对于之后所有用到 `l` 的地方，其实都是拿出了该地址下的这个列表对象，将其替换到对应的位置。

由此可以看出，Python 中的赋值操作传递给标识符的是一个引用，而非实际的值。

## 引用的传递会造成问题

因为赋值操作传递的是引用，那么在处理 `=` 这个操作符的时候就需要明确究竟需要的是什么对象的引用。

在定义函数时，我们很常见地会给一个参数指定一个默认值，以在该参数缺省时使用它。可能会有这样一段代码：

```python
def fun(x, a = []):
  a.append(x)
  return a
```

这个函数原本的目的是给一个列表 `a` 追加一个值 `x`，再返回这个列表。如果没有给定列表，则返回以 `x` 为唯一元素的新列表。

乍看起来没什么问题，但仔细观察下会发现：

1. 变量 `a` 是一个可变对象，它的值可以被修改，而不会产生新的对象。
2. 变量 `a` 是同一个列表的引用，代码中出现了3次`a`，它们地址都是同样的。
3. 默认值 `[]` 是一个列表对象，它本身具有一个地址。
4. 当调用函数时，如果省略了 `a` ，那么函数中的 `a` 指向的就是列表对象 `[]` 的地址，自然返回的也是这个地址。

如果有如下代码调用了函数 `fun()` ，可以推测一下会发生什么。

```python
def fun(e, a = []):
  a.append(e)
  return a

x = fun(1)
print(x)
y = fun(2)
print(y)
```

运行代码后会发现，打印 `x` 得到了 `[1]`，打印 `y` 得到了 `[1, 2]` ，与期望不符。甚至再接着调用 `fun(3)` 、 `fun(4)` 会发现，得到的会是不断加长的列表。

这就是传递可变对象的引用可能造成的问题。因为这几次的调用都省略了参数 `a` ，所以函数中遇到的 `a` 其实都指向的是同一个列表对象的引用。最开始是一个空列表，每一次调用都是在同一个列表后追加一个值。而函数的返回值仍然是该列表的引用，因此不论 `x` 还是 `y` ，它们实际上都是指的这一个列表对象。

## 不要将可变对象作为参数默认值

如上面的代码示例，函数参数的默认值如果是一个可变对象，会造成很隐蔽的问题。也因此，很多 IDE 以及代码审查工具会将这一写法看做是一种“坏味道”甚至是缺陷，会明显地标注出来，有的还能一键修改。我们在写代码时应注意避免这种定义函数的写法，而应改为下面的方式：

```python
def fun(e, a = None):
  if a is None:
    a = []
  a.append(e)
  return a
```

这样，`a`所指向的引用要么是从外部传进来的，要么是函数内部新定义的空列表；返回值也不再会指向同一个对象。因此对于列表的修改也就不会互相影响了。

## 延伸出的思考

由于 Python 中“赋值=引用”，以及可变对象在值发生改变时不会生成新对象的特点，我们在写代码时应该多留心：我们希望函数接收的参数是什么样的？对于它的修改应不应该反映到函数外部？函数的返回值应该如何使用？它会不会被其他地方引用到，进而被其他代码所修改？

在 `pandas` 库中，对于 `DataFrame` 的修改都会返回一个新的 `DataFrame`。这也许是一种比较安全的方式，但相对也会更多地占用空间。在自己编写的代码中，要对这种方式做一下权衡。

总之，在编写 Python 代码时，要对这种特性格外注意。
